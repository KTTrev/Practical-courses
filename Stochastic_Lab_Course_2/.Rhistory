MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left <- MED[floor(R*(1-alpha))/2]
CI_MED_right <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left <- SD[floor(R*(1-alpha))/2]
CI_SD_right <- SD[floor(R*(1-(1-alpha)/2))]
ifelse(xmed > CI_MED_left, ifelse(xmed < CI_MED_right, is_median[j] <- T, is_median[j] <- F ), is_median[j] <- F)
ifelse(sigma > CI_SD_left, ifelse(xmed < CI_SD_right, is_sd[j] <- T, is_sd[j] <- F ), is_sd[j] <- F)
}
is_median
is_sd
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left <- MED[floor(R*(1-alpha))/2]
CI_MED_right <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left <- SD[floor(R*(1-alpha))/2]
CI_SD_right <- SD[floor(R*(1-(1-alpha)/2))]
ifelse(xmed > CI_MED_left, ifelse(xmed < CI_MED_right, is_median[j] <- T, is_median[j] <- F ), is_median[j] <- F)
ifelse(sigma > CI_SD_left, ifelse(xmed < CI_SD_right, is_sd[j] <- T, is_sd[j] <- F ), is_sd[j] <- F)
}
is_sd
is_sd
sum(is_sd)
sum(is_median)
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left <- MED[floor(R*(1-alpha))/2]
CI_MED_right <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left <- SD[floor(R*(1-alpha))/2]
CI_SD_right <- SD[floor(R*(1-(1-alpha)/2))]
ifelse(xmed > CI_MED_left, ifelse(xmed < CI_MED_right, is_median[j] <- T, is_median[j] <- F ), is_median[j] <- F)
ifelse(sigma > CI_SD_left, ifelse(sigma < CI_SD_right, is_sd[j] <- T, is_sd[j] <- F ), is_sd[j] <- F)
}
is_sd
sum(is_median)
is_sd
sum(is_sd)
sum(is_sd)/M
#estimation of the coverage probability of both confidence intervals
sum(is_median)/M
sum(is_sd)/M
#estimation of the coverage probability of both confidence intervals
sum(is_median)/M
sum(is_sd)/M
?between
is_median <- 0
is_sd <- 0
alpha <- 0.95
CI_MED_left <- 0
CI_MED_right <- 0
CI_SD_left <- 0
CI_SD_right <- 0
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left[j] <- MED[floor(R*(1-alpha))/2]
CI_MED_right[j] <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left[j] <- SD[floor(R*(1-alpha))/2]
CI_SD_right[j] <- SD[floor(R*(1-(1-alpha)/2))]
df <- data.frame(CI_MED_left, CI_MED_right, CI_SD_left, CI_SD_right)
df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
}
library("dplyr", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
is_median <- 0
is_sd <- 0
alpha <- 0.95
CI_MED_left <- 0
CI_MED_right <- 0
CI_SD_left <- 0
CI_SD_right <- 0
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left[j] <- MED[floor(R*(1-alpha))/2]
CI_MED_right[j] <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left[j] <- SD[floor(R*(1-alpha))/2]
CI_SD_right[j] <- SD[floor(R*(1-(1-alpha)/2))]
df <- data.frame(CI_MED_left, CI_MED_right, CI_SD_left, CI_SD_right)
df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
}
head(df)
df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df <- df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df <- df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
head(df)
sum(df$is_sd)
sum(df$is_median)
detach("package:dplyr", unload=TRUE)
library("dplyr", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
library("dplyr")
#estimation of the coverage probability of both confidence intervals
sum(df$is_median)/M
sum(df$is_sd)/M
setwd("~/Stochastic_Lab/Stochastic_Lab_Course_2")
set.seed(1)
library("dplyr")
n <- 100 #the sample size
R <- 1000 #the number of bootstrap replications
M <- 1000 #the number of Monte Carlo samples
#Question(a)
#Simulate a sample with size n from the Weibull distribution with the scale parameter lamda = 13 and shape parameter k = 1
xmed <- 9.010913 # calculated with the formula of xmed
sigma <- 13 # calculated with the formula of sigma
l <- 13
k <- 1
#Building a two-sided bootstrap percentile confidence intervals for s = sigma and x_med at the significance level a = 0:95
#We use M Monte Carlo samples to estimate the coverage probability of both confidence intervals.
is_median <- 0
is_sd <- 0
alpha <- 0.95
CI_MED_left <- 0
CI_MED_right <- 0
CI_SD_left <- 0
CI_SD_right <- 0
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left[j] <- MED[floor(R*(1-alpha))/2]
CI_MED_right[j] <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left[j] <- SD[floor(R*(1-alpha))/2]
CI_SD_right[j] <- SD[floor(R*(1-(1-alpha)/2))]
df <- data.frame(CI_MED_left, CI_MED_right, CI_SD_left, CI_SD_right)
}
df <- df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df <- df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
#estimation of the coverage probability of both confidence intervals
sum(df$is_median)/M
sum(df$is_sd)/M
head(df)
length(df)
nrow(df)
#Estimation of the average interval length
(df$CI_MED_right - df$CI_MED_left)/nrow(df)
#Estimation of the average interval length
sum(df$CI_MED_right - df$CI_MED_left)/nrow(df)
sum(df$CI_SD_right - df$CI_SD_left)/nrow(df)
set.seed(250)
library("tidyverse")
##Question (a)
#Switch the default random number generator in R to Wichmann-Hill
RNGkind(kind = "Wichmann-Hill", normal.kind = NULL)
#Inversion method to simulate a binomial random variable
N = 1000
n = 10
p = 0.4
u <- runif(N)
bins <- .bincode(u, breaks = c(0, pbinom(0:10, 10, 0.4)), right = F, include.lowest = T)
bin_inv <- numeric()
for(i in 1:N){
bin_inv[i] <- bins[i]-1
}
#Simulation of a binomial random variable by simulating corresponding Bernoulli random variables by inversion method
bin_bern <- numeric()
for (i in 1:N){
v <- runif(n)
bin_bern[i] <- sum(v < p)
}
#Simulation of a binomial random variable with rbinom
bin_rbin <- rbinom(N, n, p)
#Plot the histograms of all three samples on one panel
bin_inv <- data.frame(bin_inv)
bin_inv$method <- rep("inverse CDF", 1000)
colnames(bin_inv) <- c("rand_num", "method")
bin_bern <- data.frame(bin_bern)
bin_bern$method <- rep("From Bernoulli", 1000)
colnames(bin_bern) <- c("rand_num", "method")
bin_rbin <- data.frame(bin_rbin)
bin_rbin$method <- rep("rbinom", 1000)
colnames(bin_rbin) <- c("rand_num", "method")
df <- rbind(bin_inv, bin_bern, bin_rbin)
ggplot(df, aes(x = rand_num, fill = method)) +
geom_histogram( binwidth=.5, position="dodge") +
labs(fill = "Simulation \n method", title = "Histograms of all three samples", x = "random numbers")
#Switch the random number generator back to its default
RNGkind(kind = "default", normal.kind = NULL)
##Question(b)
f <- function(x){
((2*pi)^(-1/2))*exp(-(x^2)/2)
}
g <- function(x){
(pi*(1 + x^2))^(-1)
}
#First determine the best value of the constant c, such that f(x) <= g(x)
x <- -1500:1500
c <- max(f(x)/g(x))
#10000 standard normal random variables using
#the accept-reject method, generating Cauchy distributed random variables using inversion method
N <- 10000
j <- 0
rand_num <- numeric()
while(length(rand_num) != N){
w <- runif(1) #step 1
cauchy <- tan((w-(1/2))*pi) #still step 1
U <- runif(1) #step 2
if(U*c*g(cauchy) <= f(cauchy)){
rand_num[j] <- cauchy #step 3
j <- j + 1
}
}
#Histogram of the obtained sample with the standard normal density
k <- rnorm(N)
df <- data.frame(rand_num, k)
ggplot(df) +
geom_histogram(aes( x = rand_num, y = ..density.., colour = rand_num), colour ="white") +
geom_density(aes(x = k), colour = "blue") +
ggtitle("Histogram of the obtained sample and plot the standard normal density")
#QQ-plot
ggplot(data = df, mapping = aes(sample = rand_num)) +
stat_qq()
#it is not possible to simulate from the standard Cauchy density using
#the accept-reject method, the standard normal candidate density
#because max(g(x)/f(x)) == Inf
#if n = R = 1000
n <- 1000
R <- 1000
is_median <- 0
is_sd <- 0
alpha <- 0.95
CI_MED_left <- 0
CI_MED_right <- 0
CI_SD_left <- 0
CI_SD_right <- 0
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left[j] <- MED[floor(R*(1-alpha))/2]
CI_MED_right[j] <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left[j] <- SD[floor(R*(1-alpha))/2]
CI_SD_right[j] <- SD[floor(R*(1-(1-alpha)/2))]
df <- data.frame(CI_MED_left, CI_MED_right, CI_SD_left, CI_SD_right)
}
df <- df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df <- df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
#estimation of the coverage probability of both confidence intervals
sum(df$is_median)/M
sum(df$is_sd)/M
#Estimation of the average interval length
sum(df$CI_MED_right - df$CI_MED_left)/nrow(df)
sum(df$CI_SD_right - df$CI_SD_left)/nrow(df)
setwd("~/Stochastic_Lab/Stochastic_Lab_Course_2")
set.seed(1)
library("dplyr")
n <- 100 #the sample size
R <- 1000 #the number of bootstrap replications
M <- 1000 #the number of Monte Carlo samples
#Question(a)
#Simulate a sample with size n from the Weibull distribution with the scale parameter lamda = 13 and shape parameter k = 1
xmed <- 9.010913 # calculated with the formula of xmed
sigma <- 13 # calculated with the formula of sigma
l <- 13
k <- 1
#Building a two-sided bootstrap percentile confidence intervals for s = sigma and x_med at the significance level a = 0:95
#We use M Monte Carlo samples to estimate the coverage probability of both confidence intervals.
is_median <- 0
is_sd <- 0
alpha <- 0.95
CI_MED_left <- 0
CI_MED_right <- 0
CI_SD_left <- 0
CI_SD_right <- 0
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left[j] <- MED[floor(R*(1-alpha))/2]
CI_MED_right[j] <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left[j] <- SD[floor(R*(1-alpha))/2]
CI_SD_right[j] <- SD[floor(R*(1-(1-alpha)/2))]
df <- data.frame(CI_MED_left, CI_MED_right, CI_SD_left, CI_SD_right)
}
df <- df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df <- df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
#estimation of the coverage probability of both confidence intervals
First_estimation_coverage_prob <- c(sum(df$is_median)/M, sum(df$is_sd)/M)
sum(df$is_median)/M
sum(df$is_sd)/M
setwd("~/Stochastic_Lab/Stochastic_Lab_Course_2")
set.seed(1)
library("dplyr")
n <- 100 #the sample size
R <- 1000 #the number of bootstrap replications
M <- 1000 #the number of Monte Carlo samples
#Question(a)
#Simulate a sample with size n from the Weibull distribution with the scale parameter lamda = 13 and shape parameter k = 1
xmed <- 9.010913 # calculated with the formula of xmed
sigma <- 13 # calculated with the formula of sigma
l <- 13
k <- 1
#Building a two-sided bootstrap percentile confidence intervals for s = sigma and x_med at the significance level a = 0:95
#We use M Monte Carlo samples to estimate the coverage probability of both confidence intervals.
is_median <- 0
is_sd <- 0
alpha <- 0.95
CI_MED_left <- 0
CI_MED_right <- 0
CI_SD_left <- 0
CI_SD_right <- 0
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left[j] <- MED[floor(R*(1-alpha))/2]
CI_MED_right[j] <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left[j] <- SD[floor(R*(1-alpha))/2]
CI_SD_right[j] <- SD[floor(R*(1-(1-alpha)/2))]
df <- data.frame(CI_MED_left, CI_MED_right, CI_SD_left, CI_SD_right)
}
df <- df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df <- df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
#estimation of the coverage probability of both confidence intervals
First_estimation_coverage_prob <- c(sum(df$is_median)/M, sum(df$is_sd)/M)
sum(df$is_median)/M
sum(df$is_sd)/M
First_coverage_prob <- c(sum(df$is_median)/M, sum(df$is_sd)/M)
sum(df$is_median)/M
sum(df$is_sd)/M
First_coverage_prob
First_average_interval_length <- c(sum(df$CI_MED_right - df$CI_MED_left)/nrow(df), sum(df$CI_SD_right - df$CI_SD_left)/nrow(df))
sum(df$CI_MED_right - df$CI_MED_left)/nrow(df)
sum(df$CI_SD_right - df$CI_SD_left)/nrow(df)
First_average_interval_length
#if n = R = 1000
n <- 1000
R <- 1000
is_median <- 0
is_sd <- 0
alpha <- 0.95
CI_MED_left <- 0
CI_MED_right <- 0
CI_SD_left <- 0
CI_SD_right <- 0
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left[j] <- MED[floor(R*(1-alpha))/2]
CI_MED_right[j] <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left[j] <- SD[floor(R*(1-alpha))/2]
CI_SD_right[j] <- SD[floor(R*(1-(1-alpha)/2))]
df <- data.frame(CI_MED_left, CI_MED_right, CI_SD_left, CI_SD_right)
}
df <- df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df <- df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
#estimation of the coverage probability of both confidence intervals
Second_coverage_prob <- c(sum(df$is_median)/M, sum(df$is_sd)/M)
#Estimation of the average interval length
Second_average_interval_length <- c(sum(df$CI_MED_right - df$CI_MED_left)/nrow(df), sum(df$CI_SD_right - df$CI_SD_left)/nrow(df))
Second_average_interval_length
Second_coverage_prob
#####if n = 100, R = 5000
n <- 100
R <- 5000
is_median <- 0
is_sd <- 0
alpha <- 0.95
CI_MED_left <- 0
CI_MED_right <- 0
CI_SD_left <- 0
CI_SD_right <- 0
for (j in 1:M) {
sample_weibull <- rweibull(n, k, l)
MED <- 0
SD <- 0
for (i in 1:R) {
myBootstrap <- sample(sample_weibull, n, replace = T)
MED[i] <- median(myBootstrap)
SD[i] <- sd(myBootstrap)
}
MED <- sort(MED)
SD <- sort(SD)
CI_MED_left[j] <- MED[floor(R*(1-alpha))/2]
CI_MED_right[j] <- MED[floor(R*(1-(1-alpha)/2))]
CI_SD_left[j] <- SD[floor(R*(1-alpha))/2]
CI_SD_right[j] <- SD[floor(R*(1-(1-alpha)/2))]
df <- data.frame(CI_MED_left, CI_MED_right, CI_SD_left, CI_SD_right)
}
df <- df %>%
mutate(is_median = xmed >= CI_MED_left & xmed <= CI_MED_right)
df <- df %>%
mutate(is_sd = sigma >= CI_SD_left & sigma <= CI_SD_right)
#estimation of the coverage probability of both confidence intervals
Third_coverage_prob <- c(sum(df$is_median)/M, sum(df$is_sd)/M)
#Estimation of the average interval length
Third_average_interval_length <- c(sum(df$CI_MED_right - df$CI_MED_left)/nrow(df), sum(df$CI_SD_right - df$CI_SD_left)/nrow(df))
install.packages("bootstrap")
library("bootstrap", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
library("bootstrap")
Third_average_interval_length
Third_coverage_prob
?bcanon
bcanon
bcanon(sample_weibull, R, theta = median, 0.95)
bcanon(sample_weibull, R, theta = median, c(0.025, 0.975))
bcanon(sample_weibull, R, theta = median, alpha = c(0.025, 0.975))
bcanon(sample_weibull, R, theta = sd, alpha = c(0.025, 0.975))
for (i in M) {
A[i]<-bcanon(sample_weibull, R, theta = median, alpha = c(0.025, 0.975))
}
A <- 0
for (i in M) {
A[i]<-bcanon(sample_weibull, R, theta = median, alpha = c(0.025, 0.975))
}
A <- list()
for (i in M) {
A[i]<-bcanon(sample_weibull, R, theta = median, alpha = c(0.025, 0.975))
}
A <- list()
a
A
A <- list(0)
A
A[1]
A[[1]]
A[[1]][1]
#Then with the sd
v <- bcanon(sample_weibull, R, theta = sd, alpha = c(0.025, 0.975))
v$confpoints
v$confpoints
v$confpoints[1,1]
