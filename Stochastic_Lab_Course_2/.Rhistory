geom_density(aes(x = rand_num, fill = method), alpha = 0.25)
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7)
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"))# values = c("pink2", "green3", "blue"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
set.seed(250)
library("tidyverse")
##Question (a)
#Switch the default random number generator in R to Wichmann-Hill
RNGkind(kind = "Wichmann-Hill", normal.kind = NULL)
#Inversion method to simulate a binomial random variable
N = 1000
n = 10
p = 0.4
u <- runif(N)
bins <- .bincode(u, breaks = c(0, pbinom(0:10, 10, 0.4)), right = F, include.lowest = T)
bin_inv <- numeric()
for(i in 1:N){
bin_inv[i] <- bins[i]-1
}
#Simulation of a binomial random variable by simulating corresponding Bernoulli random variables by inversion method
bin_bern <- numeric()
for (i in 1:N){
v <- runif(n)
bin_bern[i] <- sum(v < p)
}
#Simulation of a binomial random variable with rbinom
bin_rbin <- rbinom(N, n, p)
#Plot the empirical pdf of all three samples on one panel
bin_inv <- data.frame(bin_inv)
bin_inv$method <- rep("bin_inv", 1000)
colnames(bin_inv) <- c("rand_num", "method")
bin_bern <- data.frame(bin_bern)
bin_bern$method <- rep("bin_bern", 1000)
colnames(bin_bern) <- c("rand_num", "method")
bin_rbin <- data.frame(bin_rbin)
bin_rbin$method <- rep("bin_rbin", 1000)
colnames(bin_rbin) <- c("rand_num", "method")
df <- rbind(bin_inv, bin_bern, bin_rbin)
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method")) +
theme_bw()
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method")) +
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Cylinders") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation method") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
#Plot the empirical pdf of all three samples on one panel
bin_inv <- data.frame(bin_inv)
bin_inv$method <- rep("inverse CDF", 1000)
colnames(bin_inv) <- c("rand_num", "method")
bin_bern <- data.frame(bin_bern)
bin_bern$method <- rep("From Bernoulli", 1000)
colnames(bin_bern) <- c("rbinom", "method")
bin_rbin <- data.frame(bin_rbin)
bin_rbin$method <- rep("bin_rbin", 1000)
colnames(bin_rbin) <- c("rand_num", "method")
df <- rbind(bin_inv, bin_bern, bin_rbin)
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
head(df)
#Plot the empirical pdf of all three samples on one panel
bin_inv <- data.frame(bin_inv)
bin_inv$method <- rep("inverse CDF", 1000)
colnames(bin_inv) <- c("rand_num", "method")
head(bin_inv )
head(bin_bern)
head(bin_rbin)
set.seed(250)
library("tidyverse")
##Question (a)
#Switch the default random number generator in R to Wichmann-Hill
RNGkind(kind = "Wichmann-Hill", normal.kind = NULL)
#Inversion method to simulate a binomial random variable
N = 1000
n = 10
p = 0.4
u <- runif(N)
bins <- .bincode(u, breaks = c(0, pbinom(0:10, 10, 0.4)), right = F, include.lowest = T)
bin_inv <- numeric()
for(i in 1:N){
bin_inv[i] <- bins[i]-1
}
#Simulation of a binomial random variable by simulating corresponding Bernoulli random variables by inversion method
bin_bern <- numeric()
for (i in 1:N){
v <- runif(n)
bin_bern[i] <- sum(v < p)
}
#Simulation of a binomial random variable with rbinom
bin_rbin <- rbinom(N, n, p)
#Plot the empirical pdf of all three samples on one panel
bin_inv <- data.frame(bin_inv)
bin_inv$method <- rep("inverse CDF", 1000)
colnames(bin_inv) <- c("rand_num", "method")
bin_bern <- data.frame(bin_bern)
bin_bern$method <- rep("From Bernoulli", 1000)
colnames(bin_bern) <- c("rand_num", "method")
bin_rbin <- data.frame(bin_rbin)
bin_rbin$method <- rep("rbinom", 1000)
colnames(bin_rbin) <- c("rand_num", "method")
df <- rbind(bin_inv, bin_bern, bin_rbin)
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "gggggggggggggggg") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all
three samples") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", y = "random numbers") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", ylab = "random numbers") +
scale_colour_manual(labels = c("urban", "rural", "hi"), values = c("pink2", "green3", "blue")) +
guides(colour = guide_legend(title="Simulation method"))
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", ylab = "random numbers") +
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", y = "random numbers")
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", y = "random numbers")
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", x = "random numbers")
ggplot(df) +
geom_density(aes(x = rand_num, color = method), alpha = 0.7) +
labs(color = "Simulation \n method", title = "empirical probability density functions of all three samples", x = "random numbers")
ggplot(df) +
geom_density(aes(x = rand_num, color = method), alpha = 1) +
labs(color = "Simulation \n method", title = "empirical probability density functions of all three samples", x = "random numbers")
ggplot(df) +
geom_density(aes(x = rand_num, color = method)) +
labs(color = "Simulation \n method", title = "empirical probability density functions of all three samples", x = "random numbers")
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.7) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", x = "random numbers")
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.5) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", x = "random numbers")
?RNGkind
#Switch the random number generator back to its default
RNGkind(kind = "default", normal.kind = NULL)
#Inversion method to simulate a binomial random variable
N = 1000
n = 10
p = 0.4
u <- runif(N)
bins <- .bincode(u, breaks = c(0, pbinom(0:10, 10, 0.4)), right = F, include.lowest = T)
bin_inv <- numeric()
for(i in 1:N){
bin_inv[i] <- bins[i]-1
}
#Simulation of a binomial random variable by simulating corresponding Bernoulli random variables by inversion method
bin_bern <- numeric()
for (i in 1:N){
v <- runif(n)
bin_bern[i] <- sum(v < p)
}
#Simulation of a binomial random variable with rbinom
bin_rbin <- rbinom(N, n, p)
#Plot the empirical pdf of all three samples on one panel
bin_inv <- data.frame(bin_inv)
bin_inv$method <- rep("inverse CDF", 1000)
colnames(bin_inv) <- c("rand_num", "method")
bin_bern <- data.frame(bin_bern)
bin_bern$method <- rep("From Bernoulli", 1000)
colnames(bin_bern) <- c("rand_num", "method")
bin_rbin <- data.frame(bin_rbin)
bin_rbin$method <- rep("rbinom", 1000)
colnames(bin_rbin) <- c("rand_num", "method")
df <- rbind(bin_inv, bin_bern, bin_rbin)
ggplot(df) +
geom_density(aes(x = rand_num, fill = method), alpha = 0.5) +
labs(fill = "Simulation \n method", title = "empirical probability density functions of all three samples", x = "random numbers")
install.packages("survival")
library("survival", lib.loc="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
library("proxy", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
detach("package:proxy", unload=TRUE)
library("survival", lib.loc="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
library("survival", lib.loc="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
library("survival", lib.loc="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
library("survival", lib.loc="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
library("survival", lib.loc="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
library("survival", lib.loc="/usr/lib/R/library")
library("survival", lib.loc="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
library("survival", lib.loc="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
remove.packages("survival", lib="/usr/lib/R/library")
remove.packages("survival", lib="/usr/lib/R/library")
.libPaths(proxy)
.libPaths("proxy")
.libPaths("ggplot2")
?.libPaths()
library("tidyverse")
library("ggplot2", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
library("survival", lib.loc="/usr/lib/R/library")
library("dplyr", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
library("tidyverse", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
detach("package:tidyverse", unload=TRUE)
library("tidyverse", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
remove.packages("tidyverse", lib="~/R/x86_64-pc-linux-gnu-library/3.5")
remove.packages("survival", lib="/usr/lib/R/library")
remove.packages("survival", lib="/usr/lib/R/library")
remove.packages("survival", lib="/usr/lib/R/library")
remove.packages("survival", lib="/usr/lib/R/library")
install.packages("survival")
remove.packages("lattice", lib="/usr/lib/R/library")
remove.packages("lattice", lib="/usr/lib/R/library")
remove.packages("lattice", lib="/usr/lib/R/library")
install.packages("lattice")
library("lattice", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
remove.packages("lattice", lib="/usr/lib/R/library")
install.packages("survival")
library("survival", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.5")
remove.packages("survival", lib="/usr/lib/R/library")
detach("package:survival", unload=TRUE)
library("tidyverse")
library("survival")
install.packages("tydiverse")
install.packages("tidyverse")
library("nlme", lib.loc="/usr/lib/R/library")
remove.packages("nlme", lib="/usr/lib/R/library")
remove.packages("nlme", lib="/usr/lib/R/library")
library("bootstrap")
plot3
plot
plot1
setwd("~/Practical-courses/Stochastic_Lab_Course_2")
library("tidyverse")
library("NonpModelCheck")
#loading the data
children <- read.delim("children3.txt", sep = "")
#Question(a)
#Write an R function that calculates a local polynomial fit and depends on the response,
#covariate, bandwidth, polynomial degree, kernel and the number of derivatives.
#Implementing kernel density estimation in a function that depends on the sample, bandwidth and a kernel
i <- function(x){ifelse((abs(x)<=1),1,0)}
#kernels
nadaraya <- i
uniform <- function(x){0.5*i(x)}
triangular <- function(x){(1-abs(x))*i(x)}
epanechnikov <-function(x){(0.75*(1-x**2))*i(x)}
gaussian <- function(x){((2*pi)^(-1/2))*(exp((-x**2)/2))}
k.names <- list("uniform", "triangular", "epanechnikov", "gaussian", "nadaraya")
k.funtions <- list(uniform, triangular, epanechnikov, gaussian, nadaraya)
#local polynomial fit function
local.poly.fit <- function(Y, X, bw, l, kernel = "epanechnikov"){
# Y = response variable
# X = covariate
# bw = bandwidth
# l = polynomial degree
# kernel = epanechnikov by default
kernel <- k.funtions[[which(k.names == kernel)]]
Y <- as.matrix(Y)
X <- as.matrix(X)
d <- ncol(X)
n <- nrow(X)
X_mat <- matrix(0, d*n, l+1)
A.hat <- function(x, derivative){
# derivative = f derivative approximated. NB: derivative poly degree <= 1
term1 <- (X - x)/bw
term2 <- as.vector(t(X - x))
V <- apply(term1, MARGIN = 1, FUN = kernel)
for (i in 0:l){
X_mat[ ,i+1] <- term2^i
}
res <- lm(Y ~ X_mat - 1, weights = V) # weighted least squares (exclude intercept)
res <- res$coefficients
res <- factorial(derivative)*res[derivative + 1]
return(res)
}
VA.hat <- Vectorize(A.hat, vectorize.args = "x")
return(VA.hat)
}
#First fix the polynomial degree to 1
# and estimate f with 4 different bandwidths
fit.1 <- local.poly.fit(children$zwast, children$hypage, bw = 2, l = 1)
fit.2 <-local.poly.fit(children$zwast, children$hypage, bw = 5, l = 1)
fit.3 <-local.poly.fit(children$zwast, children$hypage, bw = 8, l = 1)
fit.4 <-local.poly.fit(children$zwast, children$hypage, bw = 11, l = 1)
#Fitting on the domain of hypage = 0:59
dfit.1 <- fit.1(x = 0:59, derivative = 0)
dfit.2 <- fit.2(x = 0:59, derivative = 0)
dfit.3 <- fit.3(x = 0:59, derivative = 0)
dfit.4 <- fit.4(x = 0:59, derivative = 0)
#dataframes for ggplot
df1 <- data.frame(a = 0:59, b = dfit.1)
df2 <- data.frame(a = 0:59, b = dfit.2)
df3 <- data.frame(a = 0:59, b = dfit.3)
df4 <- data.frame(a = 0:59, b = dfit.4)
#Then the plot
ggplot(children, aes(x = hypage, y = zwast)) +
geom_point(color = "gray31") +
geom_line(data = df1, aes(x = a, y = b, color = "2"), size = 1) +
geom_line(data = df2, aes(x = a, y = b, color = "5"), size = 1) +
geom_line(data = df3, aes(x = a, y = b, color = "8"), size = 1) +
geom_line(data = df3, aes(x = a, y = b, color = "11"), linetype = "dashed", size = 1) +
labs(color = "Bandwidth")
#now with bw = 8, we fix the polynomial degree to 1, estimate f with 4 kernels from exercise 6
fit.5 <- local.poly.fit(children$zwast, children$hypage, bw = 8, l = 1, kernel = "epanechnikov")
fit.6 <- local.poly.fit(children$zwast, children$hypage, bw = 8, l = 1, kernel = "uniform")
fit.7 <- local.poly.fit(children$zwast, children$hypage, bw = 8, l = 1, kernel = "triangular")
fit.8 <- local.poly.fit(children$zwast, children$hypage, bw = 8, l = 1, kernel = "gaussian")
#Fitting on the domain of hypage = 0:59
dfit.5 <- fit.5(x = 0:59, derivative = 0)
dfit.6 <- fit.6(x = 0:59, derivative = 0)
dfit.7 <- fit.7(x = 0:59, derivative = 0)
dfit.8 <- fit.8(x = 0:59, derivative = 0)
#dataframes for ggplot
df5 <- data.frame(a = 0:59, b = dfit.5)
df6 <- data.frame(a = 0:59, b = dfit.6)
df7 <- data.frame(a = 0:59, b = dfit.7)
df8 <- data.frame(a = 0:59, b = dfit.8)
#Then the plot
ggplot(children, aes(x = hypage, y = zwast)) +
geom_point(color = "gray31") +
geom_line(data = df5, aes(x = a, y = b, color = "epanechnikov"), size = 1) +
geom_line(data = df6, aes(x = a, y = b, color = "uniform"), size = 1) +
geom_line(data = df7, aes(x = a, y = b, color = "triangular"), size = 1) +
geom_line(data = df8, aes(x = a, y = b, color = "gaussian"),  size = 0.5) +
labs(color = "Kernel")
#Question (b)
#Write a function that calculates the optimal bandwidth with Generalised Cross Validation (GCV)
GCV <- function(Y, X, bw, l){
# Y = covariate; X = response variable; bw = bandwidth; l = polynomial degree
X_values <- unique(sort(X))
n <- length(Y)
# Precomputation of matrices X(x_i) in formula for the estimator A_hat
X_mat_list <- list()
for (i in X_values){
index = which(X_values == i)
X_mat_list[[index]] = matrix(0, n, 4+1)
aux = (X - i)
for (j in 0:4){
X_mat_list[[index]][, j+1] = aux**j
}
}
sum_square = rep(0, length(X_values)) # MSE of Y vs fitted values of X
W_trace = matrix(0, length(X_values)) # Sum of trace values of weight function W
poly_fit = local.poly.fit(Y, X, bw, l)
# Calculate components of W_trace and sum_square
for (i in X_values){
index = which(X_values == i)
aux = (X - i)
X_mat = X_mat_list[[index]][, 1:(l+1)]
V = diag(epanechnikov(aux/bw))
weight_vector = solve(t(X_mat) %*% V %*% X_mat) %*% t(X_mat) %*% V
weight_vector = weight_vector[1, ]
W_trace[index] = sum((X == i) * weight_vector)
sum_square[index] = sum((Y[(X == i)] - poly_fit(i, deriv = 0))**2)
}
res = sum(sum_square)/(1 - sum(W_trace)/n)**2
return(res)
}
#optimal bandwidth by GCV for polynomial degrees 1 to 4
Y <- children$zwast
X <- children$hypage
GCV1 <- Vectorize(function(bw){GCV(Y, X, bw, l = 1)})
GCV2 <- Vectorize(function(bw){GCV(Y, X, bw, l = 2)})
GCV3 <- Vectorize(function(bw){GCV(Y, X, bw, l = 3)})
GCV4 <- Vectorize(function(bw){GCV(Y, X, bw, l = 4)})
fit.deriv.1 <- localpoly.reg(X, Y, bandwidth = "GCV", degree.pol = 1, deriv = 1)
fit.deriv.2 <- localpoly.reg(X, Y, bandwidth = "GCV", degree.pol = 2, deriv = 1)
fit.deriv.3 <- localpoly.reg(X, Y, bandwidth = "GCV", degree.pol = 3, deriv = 1)
fit.deriv.4 <- localpoly.reg(X, Y, bandwidth = "GCV", degree.pol = 4, deriv = 1)
#dataframes for ggplot
df13 <- data.frame(a = 0:4685, b = fit.deriv.1$predict)
df14 <- data.frame(a = 0:4685, b = fit.deriv.2$predict)
df15 <- data.frame(a = 0:4685, b = fit.deriv.3$predict)
df16 <- data.frame(a = 0:4685, b = fit.deriv.4$predict)
#Plot all four derivative fits on one plot
ggplot(children, aes(x = hypage, y = zwast)) +
geom_point(color = "gray31") +
geom_line(data = df13, aes(x = a, y = b, color = "1")) +
geom_line(data = df14, aes(x = a, y = b, color = "2")) +
geom_line(data = df15, aes(x = a, y = b, color = "3")) +
geom_line(data = df16, aes(x = a, y = b, color = "4")) +
xlim(0, 59) +
labs(color = "polynomial \n degrees")
#dataframes for ggplot
df13 <- data.frame(a = 0:59, b = unique(fit.deriv.1$predict))
#dataframes for ggplot
df13 <- data.frame(a = 0:4685, b = fit.deriv.1$predict)
ggplot(children, aes(x = hypage, y = zwast)) +
geom_point(color = "gray31") +
geom_line(data = df13, aes(x = a, y = b, color = "1")) +
geom_line(data = df14, aes(x = a, y = b, color = "2")) +
geom_line(data = df15, aes(x = a, y = b, color = "3")) +
geom_line(data = df16, aes(x = a, y = b, color = "4"))
fit.deriv.1
fit.deriv.1$x
unique(fit.deriv.1$x)
max(fit.deriv.1$x)
fit.deriv.1$x
length(fit.deriv.1$x)
unique(fit.deriv.1$x)
#dataframes for ggplot
df13 <- data.frame(a = unique(fit.deriv.1$x), b = unique(fit.deriv.1$predict))
#dataframes for ggplot
df13 <- data.frame(a = unique(fit.deriv.1$x), b = unique(fit.deriv.1$predict))
df14 <- data.frame(a = unique(fit.deriv.2$x), b = unique(fit.deriv.2$predict))
df15 <- data.frame(a = unique(fit.deriv.3$x), b = unique(fit.deriv.3$predict))
df16 <- data.frame(a = unique(fit.deriv.4$x), b = unique(fit.deriv.4$predict))
#Plot all four derivative fits on one plot
ggplot(children, aes(x = hypage, y = zwast)) +
geom_point(color = "gray31") +
geom_line(data = df13, aes(x = a, y = b, color = "1")) +
geom_line(data = df14, aes(x = a, y = b, color = "2")) +
geom_line(data = df15, aes(x = a, y = b, color = "3")) +
geom_line(data = df16, aes(x = a, y = b, color = "4")) +
xlim(0, 59) +
labs(color = "polynomial \n degrees")
#Plot all four derivative fits on one plot
ggplot(children, aes(x = hypage, y = zwast)) +
geom_point(color = "gray31") +
geom_line(data = df13, aes(x = a, y = b, color = "1")) +
geom_line(data = df14, aes(x = a, y = b, color = "2")) +
geom_line(data = df15, aes(x = a, y = b, color = "3")) +
geom_line(data = df16, aes(x = a, y = b, color = "4")) +
ylim(-1.5, 1.5) +
labs(color = "polynomial \n degrees")
#Plot all four derivative fits on one plot
ggplot(children, aes(x = hypage, y = zwast)) +
geom_point(color = "gray31") +
geom_line(data = df13, aes(x = a, y = b, color = "1")) +
geom_line(data = df14, aes(x = a, y = b, color = "2")) +
geom_line(data = df15, aes(x = a, y = b, color = "3")) +
geom_line(data = df16, aes(x = a, y = b, color = "4")) +
ylim(-1.5, 1.5) +
xlim(2, 59)+
labs(color = "polynomial \n degrees")
#Plot all four derivative fits on one plot
ggplot(children, aes(x = hypage, y = zwast)) +
geom_point(color = "gray31") +
geom_line(data = df13, aes(x = a, y = b, color = "1")) +
geom_line(data = df14, aes(x = a, y = b, color = "2")) +
geom_line(data = df15, aes(x = a, y = b, color = "3")) +
geom_line(data = df16, aes(x = a, y = b, color = "4")) +
ylim(-1, 1) +
xlim(2, 59)+
labs(color = "polynomial \n degrees")
